---
title: 11) 자바스크립트 X ES6 -2 (this, arrow function, class) (작성중)
date: 2020-02-12 15:02:08
category: javascript
draft: false
---

```toc
exclude: Table of Contents
from-heading: 1
to-heading: 5
```

# 0. Intro

리액트 문법을 중 class를 이해하기 위한 포스팅

[자바스크립트 X 리액트](https://taeny.dev/javascript/9%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8x%EB%A6%AC%EC%95%A1%ED%8A%B8/)

- [자바스크립트 X ES6 -1 (variable, prototype, this)](https://taeny.dev/javascript/10%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8xes6/)에서 이어집니다.

# 1. this

## 1-1. call bind apply

앞선 포스트에서 this가 생성자 함수에서 생긴 인스턴스 객체의 호출자 역할을 한다고 알아보았다.

그럼 생성자 함수에서 생긴 인스턴스 객체를 호출하면 항상 그 객체의 속성만 써야할까?

하나의 인스턴스 객체를 통해 호출한 함수를 쓰면서, 다른 인스턴스 객체의 속성들을 사용하기 위해 나온게 위 메소드들이다.

### 1. 함수호출방식

```javascript
var example = function(a, b, c) {
  return a + b + c
}
example(1, 2, 3)
example.call(null, 1, 2, 3)
example.apply(null, [1, 2, 3])
```

[출처](https://www.zerocho.com/category/JavaScript/post/57433645a48729787807c3fd)

함수를 호출하게 되면 호출자는 브라우저에서는 this, 모듈내에서는 해당 모듈을 의미한다. nodeJS 에서는 global.

즉, `기본적으로 this는 전역객체에 바인딩`된다.

근데 함수 내장 메소드 call apply 방식으로 this를 지정해줄 수 있다.

> 하지만 'use strict' 를 통해 전역객체의 바인딩을 방지할 수도 있다.

[use strict 에서 this](https://taeny.dev/javascript/10%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8xes61/#3-2-use-strict-%EC%97%90%EC%84%9C-this)

`call` : parameter로 바인딩할 객체, arguments가 하나하나 들어감

`apply` : parameter로 바인딩할 객체, arguments가 배열형태로 들어감

### 2. call, apply(호출시 외부 객체 바인딩)

```javascript
// 객체 내부 함수에 직접 call을 적용
var obj = {
  string: 'zero',
  yell: function() {
    alert(this.string)
  },
}
var obj2 = {
  string: 'what?',
}
obj.yell() // 'zero';
obj.yell.call(obj2) // 'what?'
```

[출처](https://www.zerocho.com/category/JavaScript/post/57433645a48729787807c3fd)

### 3. bind (외부 객체 바인딩)

```javascript
var obj = {
  string: 'zero',
  yell: function() {
    alert(this.string)
  },
}
var obj2 = {
  string: 'what?',
}
var yell2 = obj.yell.bind(obj2)
yell2() // 'what?'
```

[출처](https://www.zerocho.com/category/JavaScript/post/57433645a48729787807c3fd)

### 4. 리액트에서의 bind

```javascript
class App extends React.Component {
  constructor() {
    super()
    this.handler = this.handler.bind(this)
  }

  handler() {
    this.setState({
      // ...
    })
  }

  render() {
    return <div onClick={this.handler} />
  }
}
```

> class 는 밑에서,,

# 2. arrow function

이 화살표 함수부터가 본격적인 `ES6 문법`이다.

```js
x => {
  return x
}
```

# \*. 비구조화할당

# \*. class

ECMAScript 2015(ES6) 부터 javascript 에 class 문법이 도입되었다.

1. 클래스도 함수다.

(작성중)
