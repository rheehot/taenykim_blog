---
title: 🔮 소마법 프로젝트 -7 (avengers) (작성중)
date: 2020-03-13 19:03:45
category: project
draft: false
---

```toc
exclude: Table of Contents
from-heading: 1
to-heading: 5
```

# \#. Project Map

- <a href="https://small-magic-project.now.sh/" target="_blank">프로젝트 사이트</a> :apple:

- <a href="https://github.com/taenykim/small-magic-project" target="_blank">프로젝트 깃허브소스</a>

<br/>

> 제작노트

- [소마법 프로젝트 - 1 (container)](https://taeny.dev/project/%EC%86%8C%EB%A7%88%EB%B2%95-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B81/)

- [소마법 프로젝트 - 2 (calculator)](https://taeny.dev/project/%EC%86%8C%EB%A7%88%EB%B2%95-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B82/)

- [소마법 프로젝트 - 3 (graph)](https://taeny.dev/project/%EC%86%8C%EB%A7%88%EB%B2%95-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B83/)

- [소마법 프로젝트 - 4 (crawling)](https://taeny.dev/project/%EC%86%8C%EB%A7%88%EB%B2%95-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B84/)

- [소마법 프로젝트 - 5 (today)](https://taeny.dev/project/%EC%86%8C%EB%A7%88%EB%B2%95-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B85/)

- [소마법 프로젝트 - 6 (jjal)](https://taeny.dev/project/%EC%86%8C%EB%A7%88%EB%B2%95-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B86/)

- [소마법 프로젝트 - 7 (avengers)](https://taeny.dev/project/%EC%86%8C%EB%A7%88%EB%B2%95-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B87/)

# 0. Intro

드래그 앤 드랍 기능을 간단하게 구현한 어플리케이션.

`react-beautiful-dnd` 라이브러리를 사용했고, 어벤져스 캐릭터들을 컨텐츠로 사용해보았다.

# 1. 레이아웃

## 1-1. 메인화면

![](./images/avengers.png)

화면 구성은 드래그앤드랍 기능이 들어있는 상단 컨테이너와 데이터를 화면에 그려주는 하단 컨테이너, 크게 두 개로 구성하였다.

## 1-2. 컴포넌트

```jsx
<BackgroundContainer>
  <ContentsMenubar name="avengers" data={dndData} />
  <Description>Try Drag & Drop</Description>
  <TopContainer>
    <DragDropContext>
      <DndContainer>{/* 드래그앤 드랍 관련 code */}</DndContainer>
    </DragDropContext>
  </TopContainer>
  <Description>Make them friends</Description>
  <div className="mobile_description">scroll >>> </div>
  <BottomContainer>{/* 데이터 -> 뷰 code */}</BottomContainer>
</BackgroundContainer>
```

> **ContentsMenubar** : 리듀서에 데이터를 저장하거나 데이터를 리셋시킬 수 있는 메뉴바

> **Description** : 설명 (styled-component)

> **TopContainer** : 드래그앤 드랍 기능, react-beautiful-dnd 의 `DragDropContext API`를 사용했다.

> **div.mobile_description** : width가 BottomContainer 보다 작아지면 스크롤하라는 설명도 보이도록 해주었다.

> **BottomContainer** : 데이터를 화면에 그려주는 역할

# 2. 상태관리

```jsx
const data = useSelector(state => state.avengers)
const [dndData, setDndData] = useState(data)
```

## 2-1. 리액트 state

**리액트 hooks**를 이용해서 컴포넌트 내에서의 상태관리를 하였다.

그리고 드래그앤 드랍으로 데이터의 변경시, 불변성을 유지시켜주며 데이터를 바꾸어주었다.

> **dndData** : 객체형태의 현재 column, item들의 데이터

## 2-2. 리덕스 store

**리덕스 hooks**를 이용했다.

contentsMenuBar에서 데이터를 저장하는 버튼을 누르면 `useDispatch`를 통해 데이터를 저장하고

`useSelector`로 저장된 데이터를 불러왔다.

```js
// reducers > avengers.js

const initialState = {
  items: {
    'item-1': { id: 'item-1', content: 'Captain America', src: 'captain.jpg' },
    'item-2': { id: 'item-2', content: 'IonMan', src: 'ironman.jpg' },
    'item-3': { id: 'item-3', content: 'Thor', src: 'thor.jpg' },
    'item-4': { id: 'item-4', content: 'Hulk', src: 'hulk.jpg' },
    'item-5': { id: 'item-5', content: 'Spiderman', src: 'spider.jpg' },
    'item-6': { id: 'item-6', content: 'Groot', src: 'groot.jpg' },
    'item-7': { id: 'item-7', content: 'Rocket', src: 'rocket.jpg' },
    'item-8': { id: 'item-8', content: 'Thanos', src: 'thanos.png' },
  },
  columns: {
    'column-1': {
      id: 'column-1',
      title: 'Heros',
      itemIds: [
        'item-1',
        'item-2',
        'item-3',
        'item-4',
        'item-5',
        'item-6',
        'item-7',
      ],
    },
    'column-2': {
      id: 'column-2',
      title: 'villain',
      itemIds: ['item-8'],
    },
  },
  columnOrder: ['column-1', 'column-2'],
}
```

> avengers 리듀서의 초기 state

# 3. react-beauifult-dnd

## 3-1. DragDropContext

[https://github.com/atlassian/react-beautiful-dnd](https://github.com/atlassian/react-beautiful-dnd)

![](./images/react-beautiful-dnd.gif)

```jsx
<DragDropContext
  onDragStart={onDrageStartHandler}
  onDragUpdate={onDrageUpdateHandler}
  onDragEnd={onDrageEndHandler}
>
  <DndContainer>
    {dndData.columnOrder.map(columnId => {
      const column = dndData.columns[columnId]
      const items = column.itemIds.map(itemId => dndData.items[itemId])

      return <Column key={column.id} column={column} items={items} />
    })}
  </DndContainer>
</DragDropContext>
```

<hr/>

### :apple: onDrageStartHandler

> dnd 시작시점

```jsx
const onDrageStartHandler = () => {
  for (
    let i = 0;
    i < document.querySelectorAll('.droppable_table').length;
    i++
  ) {
    document.querySelectorAll('.droppable_table')[
      i
    ].style.background = `rgba(255,141,217,0.2)`
  }
}
```

TopConatiner에서 드래그앤드랍이 발생하는 column 부분의 class를 '.droppable_table'로 정의해주고 dnd가 시작되면 그 column 배경색을 변경해주었다.

<hr/>

### :apple: onDrageUpdateHandler

> dnd 업데이트되는 시점

```jsx
const onDrageUpdateHandler = update => {
  // ...
}
```

드래그앤드랍 중, 드래그 도중 발생하는 함수. 사용하지 않음.

<hr/>

### :apple: onDrageEndHandler

> dnd 종료시점

```jsx
const onDrageEndHandler = result => {
  document.body.style.color = 'inherit'
  document.body.style.background = 'inherit'
  for (
    let i = 0;
    i < document.querySelectorAll('.droppable_table').length;
    i++
  ) {
    document.querySelectorAll('.droppable_table')[
      i
    ].style.background = `inherit`
  }
  const { destination, source, draggableId } = result
  if (!destination) {
    return
  }
  if (
    destination.droppableId === source.droppableId &&
    destination.index === source.index
  ) {
    return
  }
  const start = dndData.columns[source.droppableId] // 'column-1'
  const finish = dndData.columns[destination.droppableId]

  if (start === finish) {
    const newItemIds = Array.from(start.itemIds)
    newItemIds.splice(source.index, 1)
    newItemIds.splice(destination.index, 0, draggableId)
    const newColumn = {
      ...start,
      itemIds: newItemIds,
    }
    const newDndData = {
      ...dndData,
      columns: {
        ...dndData.columns,
        [newColumn.id]: newColumn,
      },
    }
    setDndData(newDndData)
    return
  }

  const startItemIds = Array.from(start.itemIds)
  startItemIds.splice(source.index, 1)
  const newStart = {
    ...start,
    itemIds: startItemIds,
  }

  const finishItemIds = Array.from(finish.itemIds)
  finishItemIds.splice(destination.index, 0, draggableId)
  const newFinish = {
    ...finish,
    itemIds: finishItemIds,
  }

  const newDndData = {
    ...dndData,
    columns: {
      ...dndData.columns,
      [newStart.id]: newStart,
      [newFinish.id]: newFinish,
    },
  }
  setDndData(newDndData)
  return
}
```

> 드래그 가능한 아이템을 드래그해서 드랍하면 발생하는 함수

함수가 실행될 때, result라는 객체를 전달받는다. result객체 내부는 다음과 같이 생겼다.

```jsx
const result = {
  // 드래그 한 item ID
  draggableId: '',
  // 드래그 시작 시점 column 정보
  source: {
    index: 2,
    droppableId: '',
  },
  // 드래그 종료 시점 column 정보
  destination: {
    index: 1,
    droppableId: '',
  },
}
```

이 정보를 통해서 실제 데이터를 업데이트해주었다.

먼저, 드래그 종료 시, 시작점과 목적지가 동일할 경우는 조건문 처리를 통해 다음 코드를 실행하지 않게끔 해주었고

실제 변경이 일어났을 경우, **동일한 column에서 변경**이 일어났을 때와 **다른 column으로 이동했을 경우**, 두가지를 조건문을 통해 따로 코드를 작성해주었다.

<hr/>

### 동일한 column에서 변경

```jsx
const newItemIds = Array.from(start.itemIds)
newItemIds.splice(source.index, 1)
newItemIds.splice(destination.index, 0, draggableId)
const newColumn = {
  ...start,
  itemIds: newItemIds,
}
const newDndData = {
  ...dndData,
  columns: {
    ...dndData.columns,
    [newColumn.id]: newColumn,
  },
}
setDndData(newDndData)
return
```

리액트에서 상태 변경을 감지하기 위해서 객체를 직접 변경하는 것이 아닌 새로운 객체를 만들어서 hooks로 넣어주어야한다.

> flux 패턴

그래서 객체 내부 column 배열을 변경해 주어야 하기 때문에 새로운 객체를 생성하고 source 정보와 destination 정보에 맞게 배열을 업데이트 해준 후에, 스프레드 문법으로 불변성을 유지하면서 hooks로 상태를 업데이트 해주었다.

<hr/>

### 다른 column으로 이동

```jsx
const startItemIds = Array.from(start.itemIds)
startItemIds.splice(source.index, 1)
const newStart = {
  ...start,
  itemIds: startItemIds,
}

const finishItemIds = Array.from(finish.itemIds)
finishItemIds.splice(destination.index, 0, draggableId)
const newFinish = {
  ...finish,
  itemIds: finishItemIds,
}

const newDndData = {
  ...dndData,
  columns: {
    ...dndData.columns,
    [newStart.id]: newStart,
    [newFinish.id]: newFinish,
  },
}
setDndData(newDndData)
return
```

드래그한 item이 다른 column으로 이동했을 경우는 column을 각각 수정하고 업데이트해주었다.

## 3-2. Droppable

### :apple: provided

(작성중)

# 4. 뷰 (View)

(작성중)
